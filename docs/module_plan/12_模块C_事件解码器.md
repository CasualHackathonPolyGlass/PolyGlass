# 模块C：OrderFilled 事件解码器

**模块编号**：12
**版本**：v0.1

---

## 1. 目标

对模块B产出的 logs 按 ABI 解码为结构化交易数据。

---

## 2. 接口定义

### 输入

| 参数 | 类型 | 说明 |
|------|------|------|
| `logs` | RawLog[] | 模块B产出的原始日志 |
| `abi` | ABI | OrderFilled 事件 ABI |

### 输出

```typescript
interface DecodedTrade {
  // 链上元数据
  txHash: string;
  blockNumber: number;
  logIndex: number;
  timestamp?: number;

  // 解码字段
  orderHash: string;
  maker: string;
  taker: string;
  makerAssetId: string;
  takerAssetId: string;
  makerAmountFilled: string;
  takerAmountFilled: string;
  fee: string;
}
```

---

## 3. OrderFilled 事件 ABI

### 事件签名

```solidity
event OrderFilled(
    bytes32 indexed orderHash,
    address indexed maker,
    address indexed taker,
    uint256 makerAssetId,
    uint256 takerAssetId,
    uint256 makerAmountFilled,
    uint256 takerAmountFilled,
    uint256 fee
);
```

### ABI JSON

```json
{
  "anonymous": false,
  "inputs": [
    { "indexed": true,  "name": "orderHash",         "type": "bytes32" },
    { "indexed": true,  "name": "maker",             "type": "address" },
    { "indexed": true,  "name": "taker",             "type": "address" },
    { "indexed": false, "name": "makerAssetId",      "type": "uint256" },
    { "indexed": false, "name": "takerAssetId",      "type": "uint256" },
    { "indexed": false, "name": "makerAmountFilled", "type": "uint256" },
    { "indexed": false, "name": "takerAmountFilled", "type": "uint256" },
    { "indexed": false, "name": "fee",               "type": "uint256" }
  ],
  "name": "OrderFilled",
  "type": "event"
}
```

---

## 4. 解码逻辑

### indexed 字段（从 topics 解码）

```
topics[0] = Event Signature Hash
topics[1] = orderHash (bytes32)
topics[2] = maker (address, 左填充 0)
topics[3] = taker (address, 左填充 0)
```

### non-indexed 字段（从 data 解码）

```
data = abi.encode(makerAssetId, takerAssetId, makerAmountFilled, takerAmountFilled, fee)

偏移：
  0x00-0x20: makerAssetId (uint256)
  0x20-0x40: takerAssetId (uint256)
  0x40-0x60: makerAmountFilled (uint256)
  0x60-0x80: takerAmountFilled (uint256)
  0x80-0xa0: fee (uint256)
```

---

## 5. 处理流程

```
┌─────────────────────────────────────────────────────────────┐
│                      解码流程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   for each log in logs:                                     │
│      │                                                      │
│      ▼                                                      │
│   1. 提取 indexed 字段                                       │
│      orderHash = topics[1]                                  │
│      maker = parseAddress(topics[2])                        │
│      taker = parseAddress(topics[3])                        │
│      │                                                      │
│      ▼                                                      │
│   2. 解码 data 字段                                          │
│      [makerAssetId, takerAssetId, ...]                     │
│        = decodeAbiParameters(data, types)                   │
│      │                                                      │
│      ▼                                                      │
│   3. 构建 DecodedTrade 对象                                  │
│      │                                                      │
│      ▼                                                      │
│   4. 添加到结果列表                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6. 代码接口

```typescript
// lib/trade-decoder.ts

import { decodeEventLog } from 'viem';
// 或 import { ethers } from 'ethers';

// 解码单条日志
function decodeOrderFilledLog(log: RawLog): DecodedTrade;

// 批量解码
function decodeOrderFilledLogs(logs: RawLog[]): DecodedTrade[];

// 使用 ethers.js 解码示例
function decodeWithEthers(log: RawLog): DecodedTrade {
  const iface = new ethers.Interface(ORDER_FILLED_ABI);
  const parsed = iface.parseLog({
    topics: log.topics,
    data: log.data,
  });

  return {
    txHash: log.txHash,
    blockNumber: log.blockNumber,
    logIndex: log.logIndex,
    orderHash: parsed.args.orderHash,
    maker: parsed.args.maker,
    taker: parsed.args.taker,
    makerAssetId: parsed.args.makerAssetId.toString(),
    takerAssetId: parsed.args.takerAssetId.toString(),
    makerAmountFilled: parsed.args.makerAmountFilled.toString(),
    takerAmountFilled: parsed.args.takerAmountFilled.toString(),
    fee: parsed.args.fee.toString(),
  };
}
```

---

## 7. 解码校验

### 字段校验规则

| 字段 | 校验规则 |
|------|----------|
| `maker` | 0x 开头，42 字符 |
| `taker` | 0x 开头，42 字符 |
| `orderHash` | 0x 开头，66 字符 |
| `makerAssetId` | 非空字符串 |
| `takerAssetId` | 非空字符串 |
| `makerAmountFilled` | 有效数字字符串 |
| `takerAmountFilled` | 有效数字字符串 |
| `fee` | 有效数字字符串 |

### 校验代码

```typescript
function validateDecodedTrade(trade: DecodedTrade): boolean {
  const addressRegex = /^0x[a-fA-F0-9]{40}$/;
  const bytes32Regex = /^0x[a-fA-F0-9]{64}$/;

  return (
    addressRegex.test(trade.maker) &&
    addressRegex.test(trade.taker) &&
    bytes32Regex.test(trade.orderHash) &&
    trade.makerAssetId.length > 0 &&
    trade.takerAssetId.length > 0
  );
}
```

---

## 8. 错误处理

| 错误类型 | 处理策略 |
|----------|----------|
| 解码失败 | 记录错误，跳过该条，继续处理 |
| 校验失败 | 标记为无效，不阻塞流程 |

---

## 9. 产物文件

| 文件 | 说明 |
|------|------|
| `data/decoded_trades.json` | 解码后的交易列表 |

### 文件格式示例

```json
{
  "totalDecoded": 150,
  "failedCount": 0,
  "trades": [
    {
      "txHash": "0x1234...",
      "blockNumber": 55050000,
      "logIndex": 0,
      "orderHash": "0xabcd...",
      "maker": "0x1111...",
      "taker": "0x2222...",
      "makerAssetId": "12345",
      "takerAssetId": "0",
      "makerAmountFilled": "1000000000000000000",
      "takerAmountFilled": "650000000",
      "fee": "1000000"
    }
  ]
}
```

---

## 10. 验收标准

- [ ] 输出 `data/decoded_trades.json`
- [ ] 解码条数 == 输入 logs 条数（允许少量失败）
- [ ] 每条记录 maker/taker 地址格式正确
- [ ] 对任意一条 log：解码不报错
